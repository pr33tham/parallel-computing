    1 #include <stdlib.h>
    2 #include <math.h>
    3 
    4 #define n 32
    5 #define tolerance 0.003
    6 
    7 float A[n+2][n+2], B[n+2][n+2];
    8 int stream higher[n+1], stream lower[n+1];
    9 spinlock Arrival, Departure;
   10 int i, j;
   11 boolean globaldone;
   12 int count;
   13 /*6.11*/
   14 void LocalBarrier(int i) {
   15     int dummy;
   16     if (i > 1)
   17         send(higher[i-1],1); /*send to Process i-1*/
   18     if (i < n) {
   19         send(lower[i+1],1); /*send to Process i+1*/
   20         recv(higher[i],dummy); /*receive from Process i-1*/
   21     }
   22     if (i > 1)
   23         recv(lower[i],dummy); /*receive from Process i+1*/
   24 }
   25 
   26 boolean Aggregate(boolean mydone) {
   27     boolean result;
   28     /*Arrival Phase - Count the processes arriving*/
   29     Lock(Arrival);
   30     count = count + 1;
   31     globaldone = globaldone && mydone; /*aggregation*/
   32     if (count < n) {
   33         Unlock(Arrival); /*continue Arrival Phase*/
   34     }
   35     else {
   36         Unlock(Departure); /*end Arrival Phase*/
   37     }
   38     /*Departure Phase - Count the processes leaving*/
   39     Lock(Departure);
   40     count = count - 1;
   41     result = globaldone; /*return “done” flag*/
   42     if (count > 0) {
   43         Unlock(Departure); /*continue Departure Phase*/
   44     }
   45     else {
   46         Unlock(Arrival); /*terminate Departure Phase*/
   47         globaldone = true; /*reset for new Aggregation*/
   48     }
   49     return(result);
   50 }
   51 
   52 
   53 main( ){
   54     /*Read in initial values for array A*/
   55     for(i = 1; i <= n;i++){
   56         for(j = 1; j <= n; j++ ){
   57             A[i][j] = (rand() % 200) / 200.0;
   58         }
   59     }
   60     B = A;
   61     forall i = 1 to n do {
   62         int j;
   63         float change, maxchange;
   64         boolean done;
   65         do {
   66             maxchange = 0;
   67             for(j = 1; j <= n; j++) {
   68                 B[i][j] = (A[i-1][j] + A[i+1][j] + A[i][j-1] + A[i][j+1]) / 4;
   69                 change = fabs(B[i][j] - A[i][j]);
   70                 if(change > maxchange) {
   71                     maxchange = change;
   72                 }
   73             }
   74             LocalBarrier(i);
   75             A[i] = B[i];
   76             done = Aggregate(maxchange < tolerance);
   77         }
   78         while (!done);
   79     }
   80 
   81     
   82 }
